; defining an execution context that matches any regular tab
(defcontext anyTab: {:tabQuery {:url "*://*/*"}})

; evaluating and printing something in a different context
(anyTab:(prn (+ 41 1)))

; invoking a js function
(window.alert "This works.")

; aliasing a js function
(let (anoy 'window.alert)
  (anoy "This works too. Wohoo!"))

; logging a value from a different context in this context
(console.log (schem->js (c: (prompt "How's it going over there?"))))

; combining js function invocation and js property resolution
(window.alert window.document.title)

; adding an event listener in foreign contexts (and local state)
(do
  (defcontext x: {}
    :tabQuery {:url "*://*.xkcd.com/*"}
    :features ["schem-interpreter" "dom-manipulation"])

  (x:(do)
    (def count (atom 0))
    (add-listener "click" "#ctitle" '(do)
      (swap! count #(+ 1 %))
      (window.alert (str "You clicked the title " (deref count) " times.")))))

; implementing fizz-buzz using a lazy vector
(defn fizz-buzz (start end)
  (subvec 
    (lazy-vector 
      #(cond 
        (= 0 (rem % 15)) "fizzbuzz" 
        (= 0 (rem % 3)) "fizz" 
        (= 0 (rem % 5)) "buzz"
        :else %)) 
    start end))

(fizz-buzz 0 100)

; a simple example function and macro
(defn add1 (x) (+ x 1))
(defmacro executePostfix (fn (l) (cons (last l) (butlast l))))

; just some output for whomever this file is loaded by
"example functions/macros loaded"


; clearing the local storage
(storage-clear-all)

; storing and retrieving objects in the virtual file system
(storage-create "/folder/objectName" "an invaluable value")
(storage-read "/folder/objectName")

; reading and writing scripts from the editor
(editor-load-script "code")
(editor-save-script "code")
