(do 

  (defmacro when (fn (predicate & expressions)
                     `(if ~predicate (do ~@expressions))))

  (def not (fn (a) (if a false true)))

  (def load-file 
    (fn (file) 
        (eval (read-string (str "(do " (slurp file) " )")))))

  (defmacro defn
    (fn (name & args) `(def ~name (fn ~name ~@args))))

  ; The thread first macro turns this:
  ; (-> x fn1 (fn2 y z) fn3)
  ; into this:
  ; (fn3 (fn2 (fn1 x) y z))
  (defmacro -> (fn self (value & forms)
                        (if (> (count forms) 0)
                          (let (lastForm (last forms))
                            (if (list? lastForm)
                              `(
                                ~(first lastForm)
                                ~(apply self (cons value (butlast forms)))
                                ~@(rest lastForm))
                              `(
                                ~lastForm 
                                ~(apply self (cons value (butlast forms)))))) 
                          value)))

  ; adapted from: https://github.com/kanaka/mal/blob/master/process/guide.md
  (defmacro cond (fn (& xs) 
                    (if (> (count xs) 0) 
                      (list 'if (first xs) 
                        (if (> (count xs) 1) 
                          (nth xs 1) 
                          (throw "odd number of forms supplied to cond")) 
                        (cons 'cond (rest (rest xs))))))))
